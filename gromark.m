function out=gromark(text,key,direction,varargin)
%GROnsfeld with Mixed Alphabet and Running Key Cipher encoder/decoder
%A GroMARK cipher is a hobbyist cipher. It uses a pseudorandom key
%generated by mod 10 chain addition starting from a 5-digit primer.
%This implementation expands the primer with a 5-lag addition rule:
%each new digit is mod(s(i-5)+s(i-4),10).
%Then a mixed alphabet is generated from the keyword and used with the
%running numeric key to shift letters.
%
% Syntax: 	out=gromark(text,key,direction,primer)
%
%     Input:
%           text - It is a characters array to encode or decode
%           key - It is the keyword
%           direction - this parameter can assume only two values:
%                   1 to encrypt
%                  -1 to decrypt.
%           primer - It is a characters array of five digits used to shift.
%           It is required only to encrypt.
%     Output:
%           out - It is a structure
%           out.plain = the plain text
%           out.key = the used key
%           out.primer = the used primer
%           out.encrypted = the coded text
%
% Examples:
%
% out=gromark('Hide the gold into the tree stump','leprachaun',1,'46975')
%
% out = 
% 
%   struct with fields:
% 
%         plain: 'HIDETHEGOLDINTOTHETREESTUMP'
%           key: 'LEPRACHAUN'
%        primer: '46975'
%     encrypted: '46975YQLYMDHLOOSHGAQZOHAUHSRVGGG6'
%
% out=gromark('46975YQLYMDHLOOSHGAQZOHAUHSRVGGG6','leprachaun',-1)
% 
% out = 
% 
%   struct with fields:
% 
%     encrypted: '46975YQLYMDHLOOSHGAQZOHAUHSRVGGG6'
%           key: 'LEPRACHAUN'
%        primer: '46975'
%         plain: 'HIDETHEGOLDINTOTHETREESTUMP'
%
% See also gronsfeld
%
%           Created by Giuseppe Cardillo
%           giuseppe.cardillo.75@gmail.com

p = inputParser;
addRequired(p,'text',@(x) ischar(x));
addRequired(p,'key',@(x) ischar(x));
addRequired(p,'direction',@(x) validateattributes(x,{'numeric'}, ...
    {'scalar','real','finite','nonnan','nonempty','integer','nonzero','>=',-1,'<=',1}));
addOptional(p,'primer',[],@(x) ischar(x));
parse(p,text,key,direction,varargin{:});

% Prepare key (letters only)
ckey = double(upper(key));
ckey(ckey < 65 | ckey > 90) = [];
assert(~isempty(ckey),'Key must contain at least one letter A-Z after filtering.');

% Decode/encode dispatcher and ciphertext format checks
switch direction
    case 1 % encrypt
        primer = p.Results.primer;
        assert(~isempty(primer),'Primer is needed to encrypt.');
        assert(ischar(primer) && numel(primer)==5 && all(isstrprop(primer,'digit')), ...
            'Primer must be a 5-digit char vector.');
        clear p

        % Text preprocessing
        ctext = double(upper(text));
        ctext(ctext < 65 | ctext > 90) = [];
        assert(~isempty(ctext),'Text must contain at least one letter A-Z after filtering.');

        out.plain  = char(ctext);
        out.key    = char(ckey);
        out.primer = primer;

    case -1 % decrypt
        clear p
        assert(ischar(text) && numel(text) >= 6, ...
            'Ciphertext must be at least 6 characters long (5-digit primer + control digit).');

        assert(all(isstrprop(text(1:5),'digit')) && isstrprop(text(end),'digit'), ...
            'The first 5 characters and the last must be digits.');

        primer  = text(1:5);
        control = double(text(end)) - 48;

        payload = upper(text(6:end-1));
        assert(all(payload >= 'A' & payload <= 'Z'), ...
            'Ciphertext payload must contain only letters A-Z.');

        ctext = double(payload);
        assert(~isempty(ctext),'Ciphertext payload is empty.');

        out.encrypted = text;
        out.key       = char(ckey);
        out.primer    = primer;
end

% Create the mixed alphabet from key
A = 65:1:90; % standard English alphabet
ckeyu = unique(ckey,'stable');
C = length(ckeyu);
R = ceil(26/C);
pad = R*C - 26;
B = [ckeyu A(~ismember(A,ckeyu)) zeros(1,pad)];
PS = reshape(B,[C,R])';
[~,Idx] = sort(ckeyu);
PS = reshape(PS(:,Idx),1,[]);
PS(PS==0) = [];
clear A B C R pad Idx ckeyu

% Expand the primer using the 5-lag mod-10 rule
LT = length(ctext);
s = zeros(1,LT);
s(1:5) = double(primer) - 48;
for I = 6:LT
    s(I) = mod(s(I-5) + s(I-4), 10);
end
clear I

switch direction
    case 1 % encrypt
        % Build output with primer + payload + control digit
        tmp = zeros(1,LT+6);
        tmp(1:5) = s(1:5) + 48;
        tmp(end) = s(end) + 48;

        plainIdx  = ctext - 65;                 % 0..25
        cipherIdx = mod(plainIdx + s, 26) + 1;  % 1..26
        tmp(6:end-1) = PS(cipherIdx);

        out.encrypted = char(tmp);
        out.key = char(ckey);

        clear tmp plainIdx cipherIdx

    case -1 % decrypt
        assert(control == s(end), ...
            'Control code was not generated from reported primer.');
        clear control

        % Map ciphertext letters to PS positions
        [tf,cipherIdx] = ismember(ctext, PS);
        assert(all(tf), 'Ciphertext contains letters not present in the mixed alphabet.');
        clear tf

        % Invert the shift (fix off-by-one)
        plainIdx = mod((cipherIdx - 1) - s, 26) + 1; % 1..26
        out.plain = char(plainIdx + 64);

        clear cipherIdx plainIdx
end

clear ctext LT PS s
end
