function out=gromark(text,key,direction,varargin)
%GROnsfeld with Mixed Alphabet and Running Key Cipher encoder/decoder
%A GroMARK cipher is a hobbyist cipher. It uses what is called a
%pseudorandom key generated by mod 10 chain addition. That sounds
%complicated, but it really isn't. You start with a key number, called a
%primer. Let's use 4835 as an example. You keep generating more numbers at
%the end by adding together the digits in pairs, saving only the final
%digit if the sum is 10 or more. In this case since 4+8=12, you discard the
%1 and append 2 to the end, so the key is now 48352. Since 8+3=11 then next
%digit is a 1, and you have 483521. 
%You continue this until you have one digit for every letter of the
%message you are encrypting. Next you create a mixed alphabet and place it
%directly below a regular alphabet. For each letter to be enciphered you
%find it in the regular (plaintext) alphabet, count to the right the number
%of characters shown by the key number, and take the letter in the mixed
%(ciphertext) alphabet below. That's the next ciphertext letter. To decrypt
%a message you create the same cipher alphabet and pseudorandom key
%(because you know the primer) and just reverse it. You find the ciphertext
%letter in the mixed alphabet, count the right number of letters to the
%left and the letter above is the plaintext letter. That's all there is to
%it.
%
% Syntax: 	out=gronsfeld(text,key,direction,primer)
%
%     Input:
%           text - It is a characters array to encode or decode
%           key - It is the keyword
%           direction - this parameter can assume only two values: 
%                   1 to encrypt
%                  -1 to decrypt.
%           primer - It is a characters array of five digits used to shift.
%           It is required only to encrypt.
%     Output:
%           out - It is a structure
%           out.plain = the plain text
%           out.key = the used key
%           out.primer = the used primer
%           out.encrypted = the coded text
% Examples:
%
% out=gromark('Hide the gold into the tree stump','leprachaun',1,'46975')
%
% out = 
% 
%   struct with fields:
% 
%         plain: 'HIDETHEGOLDINTOTHETREESTUMP'
%           key: 'LEPRACHAUN'
%        primer: '46975'
%     encrypted: '46975YQLYMDHLOOSHGAQZOHAUHSRVGGG6'
%
% out=gromark('46975YQLYMDHLOOSHGAQZOHAUHSRVGGG6','leprachaun',-1)
% 
% out = 
% 
%   struct with fields:
% 
%     encrypted: '46975YQLYMDHLOOSHGAQZOHAUHSRVGGG6'
%           key: 'LEPRACHAUN'
%        primer: '46975'
%         plain: 'HIDETHEGOLDINTOTHETREESTUMP'
%
% See also gronsfeld
%
%           Created by Giuseppe Cardillo
%           giuseppe.cardillo.75@gmail.com

p = inputParser;
addRequired(p,'text',@(x) ischar(x));
addRequired(p,'key',@(x) ischar(x));
addRequired(p,'direction',@(x) validateattributes(x,{'numeric'},{'scalar','real','finite','nonnan','nonempty','integer','nonzero','>=',-1,'<=',1}));
addOptional(p,'primer',[],@(x) ischar(x));
parse(p,text,key,direction,varargin{:});

% Set all letters in uppercase and convert into ASCII Code.
ckey=double(upper(key)); 
% Erase all characters that are not into the range 65 - 90
ckey(ckey<65 | ckey>90)=[];

switch direction
    case 1 %encrypt
        primer=p.Results.primer;
        assert(~isempty(primer),'Primer is needed to encrypt')
        assert(length(primer)==5,'Primer must be 5 digits long')
        clear p
        ctext=double(upper(text)); 
        ctext(ctext<65 | ctext>90)=[]; 
        out.plain=char(ctext);
        out.key=char(ckey);
        out.primer=primer;
    case -1 %decrypt
        clear p
        assert(length(regexp(text([1:5 end]),'\d'))==6,'The first 5 characters and the last must be digits')
        primer=text(1:5);
        control=double(text(end))-48;
        ctext=double(upper(text(6:end-1)));
        ctext(ctext<65 | ctext>90)=[]; 
        out.encrypted=text;
        out.key=char(ckey);
        out.primer=primer;
end 

%Create the encoding alphabet
A=65:1:90; %standard english alphabet
% Chars of the key must be choosen only once
ckey=unique(ckey,'stable');
% then all the other letters into alphabetically order
C=length(ckey); %you need C columns as key length
R=ceil(26/C); %you need an integer number of row...
pad=R*C-26; %... if you need use a padding array
B=[ckey A(~ismember(A,ckey)) zeros(1,pad)];
% Create the matrix
PS=reshape(B,[C,R])';
clear A B C R pad
% Columnar trasposition using key index
[~,Idx]=sort(ckey);
% after transposition take letters vertically
PS=reshape(PS(:,Idx),1,[]);
% and erase the pad
PS(PS==0)=[];
clear Idx ckey

%now expand the primer using Fibonacci sequence rule 
LT=length(ctext); %length of the expanded primer
s=zeros(1,LT); %vector preallocation
s(1:5)=double(primer)-48;
for I=6:LT
    s(I)=mod(s(I-5)+s(I-4),10);
end
clear I

switch direction
    case 1 %encrypt
        tmp=zeros(1,LT+6); %vector preallocation
        clear LT A
        %the first 5 positions are occupied by the primer
        tmp(1:5)=s(1:5)+48;
        %the last position is the last expanded primer digit as control digit
        tmp(end)=s(end)+48;
        L=65;
        while any(tmp(6:end-1)==0) || L<=90
            IdxL=find(ctext==L); 
            tmp(IdxL+5)=PS(mod((L-65)+s(IdxL),26)+1);
            L=L+1;
        end
        out.encrypted=char(tmp);
        clear L PS fun tmp s ctext IdxL
    case -1 %decrypt
        assert(control==s(end),'Control code was not generated from reported primer')
        clear control
        tmp=zeros(1,LT); %vector preallocation
        clear LT
        L=65;
        while any(tmp==0) || L<=90
            IdxL=find(ctext==L);
            tmp(IdxL)=mod(find(PS==L)-s(IdxL),26)+64;
            L=L+1;
        end
        clear L s ctext PS IdxL
        out.plain=char(tmp);
        clear tmp
end 